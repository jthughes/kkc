// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: player_status.sql

package database

import (
	"context"
	"database/sql"
)

const getAllPlayerStatus = `-- name: GetAllPlayerStatus :many
SELECT id, created_at, player_id, turn_id, sane, crockery, lodging, imre, university, medica, coin, ep_linguistics, ep_arithmetics, ep_rhetoric_and_logic, ep_archives, ep_sympathy, ep_physicking, ep_alchemy, ep_artificery, ep_naming FROM player_status
`

func (q *Queries) GetAllPlayerStatus(ctx context.Context) ([]PlayerStatus, error) {
	rows, err := q.db.QueryContext(ctx, getAllPlayerStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerStatus
	for rows.Next() {
		var i PlayerStatus
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.PlayerID,
			&i.TurnID,
			&i.Sane,
			&i.Crockery,
			&i.Lodging,
			&i.Imre,
			&i.University,
			&i.Medica,
			&i.Coin,
			&i.EpLinguistics,
			&i.EpArithmetics,
			&i.EpRhetoricAndLogic,
			&i.EpArchives,
			&i.EpSympathy,
			&i.EpPhysicking,
			&i.EpAlchemy,
			&i.EpArtificery,
			&i.EpNaming,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatusByID = `-- name: GetPlayerStatusByID :one
SELECT id, created_at, player_id, turn_id, sane, crockery, lodging, imre, university, medica, coin, ep_linguistics, ep_arithmetics, ep_rhetoric_and_logic, ep_archives, ep_sympathy, ep_physicking, ep_alchemy, ep_artificery, ep_naming FROM player_status
WHERE player_id = $1 AND turn_id = $2
`

type GetPlayerStatusByIDParams struct {
	PlayerID int32
	TurnID   int32
}

func (q *Queries) GetPlayerStatusByID(ctx context.Context, arg GetPlayerStatusByIDParams) (PlayerStatus, error) {
	row := q.db.QueryRowContext(ctx, getPlayerStatusByID, arg.PlayerID, arg.TurnID)
	var i PlayerStatus
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.PlayerID,
		&i.TurnID,
		&i.Sane,
		&i.Crockery,
		&i.Lodging,
		&i.Imre,
		&i.University,
		&i.Medica,
		&i.Coin,
		&i.EpLinguistics,
		&i.EpArithmetics,
		&i.EpRhetoricAndLogic,
		&i.EpArchives,
		&i.EpSympathy,
		&i.EpPhysicking,
		&i.EpAlchemy,
		&i.EpArtificery,
		&i.EpNaming,
	)
	return i, err
}

const newPlayerStatus = `-- name: NewPlayerStatus :one
INSERT INTO player_status (player_id, turn_id, sane, crockery, lodging, imre, university, medica, coin, ep_linguistics, ep_arithmetics, ep_rhetoric_and_logic, ep_archives, ep_sympathy, ep_physicking, ep_alchemy, ep_artificery, ep_naming)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18
)
RETURNING id, created_at, player_id, turn_id, sane, crockery, lodging, imre, university, medica, coin, ep_linguistics, ep_arithmetics, ep_rhetoric_and_logic, ep_archives, ep_sympathy, ep_physicking, ep_alchemy, ep_artificery, ep_naming
`

type NewPlayerStatusParams struct {
	PlayerID           int32
	TurnID             int32
	Sane               bool
	Crockery           bool
	Lodging            sql.NullBool
	Imre               sql.NullBool
	University         sql.NullBool
	Medica             sql.NullBool
	Coin               float64
	EpLinguistics      int32
	EpArithmetics      int32
	EpRhetoricAndLogic int32
	EpArchives         int32
	EpSympathy         int32
	EpPhysicking       int32
	EpAlchemy          int32
	EpArtificery       int32
	EpNaming           int32
}

func (q *Queries) NewPlayerStatus(ctx context.Context, arg NewPlayerStatusParams) (PlayerStatus, error) {
	row := q.db.QueryRowContext(ctx, newPlayerStatus,
		arg.PlayerID,
		arg.TurnID,
		arg.Sane,
		arg.Crockery,
		arg.Lodging,
		arg.Imre,
		arg.University,
		arg.Medica,
		arg.Coin,
		arg.EpLinguistics,
		arg.EpArithmetics,
		arg.EpRhetoricAndLogic,
		arg.EpArchives,
		arg.EpSympathy,
		arg.EpPhysicking,
		arg.EpAlchemy,
		arg.EpArtificery,
		arg.EpNaming,
	)
	var i PlayerStatus
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.PlayerID,
		&i.TurnID,
		&i.Sane,
		&i.Crockery,
		&i.Lodging,
		&i.Imre,
		&i.University,
		&i.Medica,
		&i.Coin,
		&i.EpLinguistics,
		&i.EpArithmetics,
		&i.EpRhetoricAndLogic,
		&i.EpArchives,
		&i.EpSympathy,
		&i.EpPhysicking,
		&i.EpAlchemy,
		&i.EpArtificery,
		&i.EpNaming,
	)
	return i, err
}
